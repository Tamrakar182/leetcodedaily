{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetCode Daily Challenge Attempt 2 (Ongoing)","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is my second attempt to do the LeetCode Daily Challenge. I will be using Obsidian to take notes and publish them with MkDocs.</p> <p>Check my previous Attempt here</p> <p>Update 23</p>"},{"location":"Previous%20Attempts/","title":"LeetCode Daily Challenge Attempt 1 (Failed)","text":""},{"location":"Previous%20Attempts/#introduction","title":"Introduction","text":"<p>This is my attempt to do the LeetCode Daily Challenge. I will be using Obsidian to take notes and publish them with MkDocs. Started from the 1st of July to 12th July Failed Attempt 1, wasn't able to follow through due to disinterest.</p>"},{"location":"Previous%20Attempts/#leetcode-75","title":"LeetCode 75","text":"<p>These are my notes for the \"Ace Coding Interview with 75 Qs\".</p> <ul> <li> <p>Day 1 Merge Strings Alternately</p> </li> <li> <p>Day 2 Greatest Common Divisor of Strings</p> </li> <li> <p>Day 3 Kids with the Greates Number of Candies</p> </li> <li> <p>Day 4 Can Place Flowers</p> </li> <li> <p>Day 5 Reverse Vowels of a String</p> </li> <li> <p>Day 6 Reverse Words in a String</p> </li> <li> <p>Day 7 Product of Array Except Self</p> </li> <li> <p>Day 8 Increasing Triplet Subsequence</p> </li> <li> <p>Day 9 String Compression</p> </li> <li> <p>Day 10 Move Zeroes</p> </li> <li> <p>Day 11 Is Subsequence</p> </li> <li> <p>Day 12 Container With Most Water</p> </li> <li> <p>Day 13 Max Number of K-Sum Pairs</p> </li> </ul>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%201%20Merge%20Strings%20Alternately/","title":"1768. Merge Strings Alternately","text":"<p>Topics: #twopointers #string #easy</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%201%20Merge%20Strings%20Alternately/#problem-statement","title":"Problem Statement","text":"<p>You are given two strings\u00a0<code>word1</code>\u00a0and\u00a0<code>word2</code>. Merge the strings by adding letters in alternating order, starting with\u00a0<code>word1</code>. If a string is longer than the other, append the additional letters onto the end of the merged string.</p> <p>Return\u00a0the merged string.</p> <pre><code>Input: word1 = \"abc\", word2 = \"pqr\"\nOutput: \"apbqcr\"\nExplanation:\u00a0The merged string will be merged as so:\nword1:  a   b   c\nword2:    p   q   r\nmerged: a p b q c r\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%201%20Merge%20Strings%20Alternately/#my-approach","title":"My Approach","text":"<p><pre><code>def mergeAlternately(word1: str, word2: str) -&gt; str:\n    emptyString = \"\"\n    i = 0\n    j = 0\n    while(i&lt;len(word1) and j&lt;len(word2)):\n        emptyString += word1[i]\n        emptyString += word2[j]\n        i += 1\n        j += 1\n    if len(word1)&gt;len(word2):\n        for k in range(i, len(word1)):\n            emptyString += word1[k]\n    else:\n        for l in range(j, len(word2)):\n            emptyString += word2[l]\n    return emptyString\n</code></pre> I used a while loop which appended the letters alternately in a new string <code>emptyString</code>. Afterwards, I checked for the longer string and if any letters were left over, appended them to <code>emptyString</code> and returned it. </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%201%20Merge%20Strings%20Alternately/#personal-thoughts","title":"Personal Thoughts","text":"<p>This problem wasn't that hard but my solution wasn't the best as well. I couldv'e utilized python's inbuilt slicing methods to get rid of an extra loop and many more optimization strategies but well if it ain't broke, dont fix it. </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2010%20Move%20Zeroes/","title":"283. Move Zeroes","text":"<p>Tags: #array #twopointers #easy </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2010%20Move%20Zeroes/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array\u00a0<code>nums</code>, move all\u00a0<code>0</code>'s to the end of it while maintaining the relative order of the non-zero elements.</p> <p>Note\u00a0that you must do this in-place without making a copy of the array.</p> <pre><code>Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2010%20Move%20Zeroes/#my-approach","title":"My Approach","text":"<p><pre><code>class Solution:\n    def moveZeroes(self, nums: List[int]) -&gt; None:\n        for i in nums:\n            if i == 0:\n                nums.remove(i)\n                nums.append(i)\n</code></pre> This was the first approach I thought of where we loop over the <code>nums</code> array once and if there is an element 0, we remove it and append it to the end of the list. However, I came up with another solution that gets rid of the loop. <pre><code>class Solution:\n    def moveZeroes(self, nums: List[int]) -&gt; None:\n        if 0 in nums:\n            count = nums.count(0)\n            nums[:] = [i for i in nums if i!= 0]\n            nums.extend([0]*count)\n</code></pre> In this solution, first we check if there's 0 or not in the <code>nums</code> array and if there is, we count the number of zero's in <code>count</code>. Then, we change the <code>nums</code> array in place by using list comprehension (Note: the <code>nums[:]</code> is required here since the default list comprehension would make a new array and point to that instead ) and remove all the zeros. Then using <code>extend()</code>, we add the zeros in the end, multipled by <code>count</code> for every zero we have.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2010%20Move%20Zeroes/#personal-thoughts","title":"Personal Thoughts","text":"<p>This is another hacky solution since I mostly utilised python methods and functionality. Will try to solve using a more conventional approach on a later date.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2011%20Is%20Subsequence/","title":"392. Is Subsequence","text":"<p>Tags: #twopointers #string #dynamicprogramming #easy </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2011%20Is%20Subsequence/#problem-statement","title":"Problem Statement","text":"<p>Given two strings\u00a0<code>s</code>\u00a0and\u00a0<code>t</code>, return\u00a0<code>true</code> if <code>s</code> is a\u00a0subsequence\u00a0of <code>t</code>, or <code>false</code> otherwise.</p> <p>A\u00a0subsequence\u00a0of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,\u00a0<code>\"ace\"</code>\u00a0is a subsequence of\u00a0<code>\"abcde\"</code>\u00a0while\u00a0<code>\"aec\"</code>\u00a0is not).</p> <pre><code>Input: s = \"axc\", t = \"ahbgdc\"\nOutput: false\n\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2011%20Is%20Subsequence/#my-approach","title":"My approach","text":"<p><pre><code>class Solution:\n    def isSubsequence(self, s: str, t: str) -&gt; bool:\n        r=0\n        if s==\"\":\n            return True\n        for i in t:\n            if r&lt;len(s) and s[r] == i:\n                r+=1\n        return r==len(s)\n</code></pre> In this solution, first we check if the subsequent string is empty upon which it will be a subsequence no matter what. Then we loop over <code>t</code>, the string to be checked against and if <code>r</code> is less than the length of <code>s</code> (this prevents a list out of index exception) and the current element is same as <code>s</code>'s <code>rth</code> item then, we increment r. Finally, we check if <code>r</code> is equal to the assumed subsequence length, returning <code>True</code> or <code>False</code>. </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2011%20Is%20Subsequence/#personal-thoughts","title":"Personal Thoughts","text":"<p>This was a rather simple approach suggested by one of our classmates when I was thinking of a more complex one involving two loops.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2012%20Container%20With%20Most%20Water/","title":"11.\u00a0Container With Most Water","text":"<p>Tags: #array #twopointers #greedy #medium </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2012%20Container%20With%20Most%20Water/#problem-statement","title":"Problem Statement","text":"<p>You are given an integer array\u00a0<code>height</code>\u00a0of length\u00a0<code>n</code>. There are\u00a0<code>n</code>\u00a0vertical lines drawn such that the two endpoints of the\u00a0<code>ith</code>\u00a0line are\u00a0<code>(i, 0)</code>\u00a0and\u00a0<code>(i, height[i])</code>.</p> <p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p> <p>Return\u00a0the maximum amount of water a container can store.</p> <p>Notice\u00a0that you may not slant the container.</p> <p></p> <pre><code>Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2012%20Container%20With%20Most%20Water/#my-approach","title":"My Approach","text":"<pre><code>class Solution:\n    def maxArea(self, height: List[int]) -&gt; int:\n        i = 0\n        j = len(height)-1\n        temp = 0\n        primary = 0\n        while(i&lt;j):\n            temp = min(height[i], height[j])*(j-i)\n            if temp &gt; primary:\n                primary = temp\n            if height[j]&gt;height[i]:\n                i+=1\n            else:\n                j-=1\n        return primary\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2012%20Container%20With%20Most%20Water/#personal-thoughts","title":"Personal Thoughts","text":""},{"location":"Previous%20Attempts/LeetCode%2075/Day%2013%20Max%20Number%20of%20K-Sum%20Pairs/","title":"1679.\u00a0Max Number of K-Sum Pairs","text":"<p>Tags: #array #twopointers #sorting #hashtable #medium </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2013%20Max%20Number%20of%20K-Sum%20Pairs/#problem-statement","title":"Problem Statement","text":"<p>You are given an integer array\u00a0<code>nums</code>\u00a0and an integer\u00a0<code>k</code>.</p> <p>In one operation, you can pick two numbers from the array whose sum equals\u00a0<code>k</code>\u00a0and remove them from the array.</p> <p>Return\u00a0the maximum number of operations you can perform on the array.</p> <pre><code>Input: nums = [1,2,3,4], k = 5\nOutput: 2\nExplanation: Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2013%20Max%20Number%20of%20K-Sum%20Pairs/#my-approach","title":"My Approach","text":"<pre><code>class Solution:\n    def maxOperations(self, nums: List[int], k: int) -&gt; int:\n        i = 0\n        j = len(nums)-1\n        count = 0\n        nums.sort()\n\n        while(i&lt;j):\n            sum =nums[i]+nums[j] \n            if  sum == k:\n                count +=1\n                i+=1\n                j-=1\n            elif sum &lt; k:\n                i+=1\n            else:\n                j-=1\n        return count\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%2013%20Max%20Number%20of%20K-Sum%20Pairs/#personal-thoughts","title":"Personal Thoughts","text":""},{"location":"Previous%20Attempts/LeetCode%2075/Day%202%20Greatest%20Common%20Divisor%20of%20Strings/","title":"1071.\u00a0Greatest Common Divisor of Strings","text":"<p>Tags: #Math #string #easy</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%202%20Greatest%20Common%20Divisor%20of%20Strings/#problem-statement","title":"Problem Statement","text":"<p>For two strings\u00a0<code>s</code>\u00a0and\u00a0<code>t</code>, we say \"<code>t</code>\u00a0divides\u00a0<code>s</code>\" if and only if\u00a0<code>s = t + ... + t</code>\u00a0(i.e.,\u00a0<code>t</code>\u00a0is concatenated with itself one or more times).</p> <p>Given two strings\u00a0<code>str1</code>\u00a0and\u00a0<code>str2</code>, return\u00a0the largest string <code>x</code> such that <code>x</code> divides both <code>str1</code> and <code>str2</code>.</p> <pre><code>Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%202%20Greatest%20Common%20Divisor%20of%20Strings/#my-approach","title":"My approach","text":"<p><pre><code>class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -&gt; str:\n        l1 = len(str1)\n        l2 = len(str2)\n        gcd = \"\"\n        if l1&lt;l2:\n            str1, str2 = str2, str1\n        for i in range(l2):\n            if i == 0:\n                temp = str2[0]\n            else:\n                temp = str2[:i+1]\n            factor1 = len(str1)//len(temp) \n            factor2 = len(str2)//len(temp)\n            if temp*factor1 == str1 and temp*factor2== str2:\n                gcd = temp\n        return gcd\n</code></pre> So, here what I did is, at first I took the sizes of two string in l1 and l2 and also initialised an empty gcd. Comparing the two string's length, I made it so that str1 was the longer of the two strings always. Then in a for loop, I checked if it's the first element, and stored in the temp otherwise took all the element up until i and stored it. Afterthat, I calculated the factor1 and factor2 which represents how many times, temp can fit into str2 without any remainders. Finally, I checked if temp is a common divisor of both str1 and str2, upon which we have gotten our Greatest Common Divisor upon the completion of the loop. In the end, we return gcd.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%202%20Greatest%20Common%20Divisor%20of%20Strings/#personal-thoughts","title":"Personal Thoughts","text":"<p>This question was my first forte into actually reading into what the question actually says and I had to think long and hard before attempting anything. Unfortunately, I wasn't able to solve this problem alone and took some help from a friend but well collaboration is key in coding. On to the next one!!!</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%203%20Kids%20with%20the%20Greates%20Number%20of%20Candies/","title":"1431.\u00a0Kids With the Greatest Number of Candies","text":"<p>Tags: #array #easy</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%203%20Kids%20with%20the%20Greates%20Number%20of%20Candies/#problem-statement","title":"Problem Statement","text":"<p>There are\u00a0<code>n</code>\u00a0kids with candies. You are given an integer array\u00a0<code>candies</code>, where each\u00a0<code>candies[i]</code>\u00a0represents the number of candies the\u00a0<code>ith</code>\u00a0kid has, and an integer\u00a0<code>extraCandies</code>, denoting the number of extra candies that you have.</p> <p>Return\u00a0a boolean array <code>result</code> of length <code>n</code>, where <code>result[i]</code> is <code>true</code> if, after giving the <code>ith</code> kid all the <code>extraCandies</code>, they will have the\u00a0greatest\u00a0number of candies among all the kids__, or <code>false</code> otherwise.</p> <p>Note that\u00a0multiple\u00a0kids can have the\u00a0greatest\u00a0number of candies.</p> <pre><code>Input: candies = [4,2,1,1,2], extraCandies = 1\nOutput: [true,false,false,false,false] \nExplanation: There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%203%20Kids%20with%20the%20Greates%20Number%20of%20Candies/#my-approach","title":"My approach","text":"<p><pre><code>def func(candies, extraCandies):\n    maximum = max(candies)\n    result = [False for i in candies]\n    for i in range(len(candies)):\n        x = candies[i]\n        if x+extraCandies &gt;= maximum:\n            result[i] = True\n    return result\n</code></pre> Here, first I take the maximum from the candies and also initialise an array of Falses into result the size of candies list. Then, I check each candy x against the maximum and convert the candy's position as True in the result.</p> <p><pre><code>import numpy as np\n\ndef func(candies, extraCandies):\n    np_array = np.array(candies)\n    return ((np_array+extraCandies) &gt;= extraCandies)\n</code></pre> This is another approach that I thought of using the numpy package since it just natively returned a Boolean array when a condition is passed to a numpy.array.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%203%20Kids%20with%20the%20Greates%20Number%20of%20Candies/#personal-thoughts","title":"Personal Thoughts","text":"<p>This problem wasn't that difficult and was fairly obvious once you thought about it. And about using external libraries, I'm totally fine with using them even though they might obfuscate the underlying logic and add an abstraction layer.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%204%20Can%20Place%20Flowers/","title":"605.\u00a0Can Place Flowers","text":"<p>Tags: #array #greedy #easy</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%204%20Can%20Place%20Flowers/#problem-statement","title":"Problem Statement","text":"<p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in\u00a0adjacent\u00a0plots.</p> <p>Given an integer array\u00a0<code>flowerbed</code>\u00a0containing\u00a0<code>0</code>'s and\u00a0<code>1</code>'s, where\u00a0<code>0</code>\u00a0means empty and\u00a0<code>1</code>\u00a0means not empty, and an integer\u00a0<code>n</code>, return\u00a0<code>true</code> if <code>n</code> new flowers can be planted in the <code>flowerbed</code> without violating the no-adjacent-flowers rule and <code>false</code> otherwise.</p> <pre><code>Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%204%20Can%20Place%20Flowers/#my-approach","title":"My approach","text":"<p><pre><code>def func(array, n):\n    count = 0\n    i = 0\n    while i&lt;len(array):\n        if array[i] == 1 or array[i+1]==1 or array[i+2]==1:\n            i+=1\n        else:\n            count +=1\n            i+=2\n    if count == n:\n        return True\n    return False\n</code></pre> In my approach, I just made a loop so that it checked whether the current element, the next element and the next-next element is <code>one</code> upon which we iterate over to the next element otherwise, we increment the <code>count</code> and iterate over to the next-next element since, the next element has already been checked. After the loop, if the counter variable is equals to the given number then, we return <code>True</code> otherwise <code>False</code></p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%204%20Can%20Place%20Flowers/#personal-thoughts","title":"Personal Thoughts","text":"<p>Another Trivial question. The initial concept was quite interesting to figure out and luckily the implementation worked once we (Me and My Friend) thought about the problem properly.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%205%20Reverse%20Vowels%20of%20a%20String/","title":"345.\u00a0Reverse Vowels of a String","text":"<p>Tags: #twopointers #string #easy</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%205%20Reverse%20Vowels%20of%20a%20String/#problem-statement","title":"Problem Statement","text":"<p>Given a string\u00a0<code>s</code>, reverse only all the vowels in the string and return it.</p> <p>The vowels are\u00a0<code>'a'</code>,\u00a0<code>'e'</code>,\u00a0<code>'i'</code>,\u00a0<code>'o'</code>, and\u00a0<code>'u'</code>, and they can appear in both lower and upper cases, more than once.</p> <pre><code>Input: s = \"leetcode\"\nOutput: \"leotcede\"\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%205%20Reverse%20Vowels%20of%20a%20String/#my-approach","title":"My approach","text":"<p><pre><code>class Solution:\n    def reverseVowels(self, s: str) -&gt; str:\n        i = 0\n        j = len(s)-1\n        vowel = \"aeiouAEIOU\"\n        s = list(s)\n        while i&lt;j:\n            if s[i] in vowel and s[j] in vowel:\n                s[i], s[j] = s[j], s[i]\n                j-=1\n                i+=1\n            elif s[i] in vowel:\n                j-=1\n            elif s[j] in vowel:\n                i+=1\n            else:\n                i+=1\n                j-=1\n        s =\"\".join(map(str,s))\n        return s\n</code></pre> In my approach, first I took a <code>vowel</code> string to check against every list item. In a while loop, I checked whether the current element and the last element was in the vowels list, upon which if the condition was True, I swapped them and incremented <code>i</code> and decremented <code>j</code>. For the other condition, if we only found vowel match in the current element then, we increment <code>i</code> otherwise if we only found in the last element then, we decrement <code>j</code>. Finally, if none of those conditions match, then we increment both <code>i</code> and <code>j</code> to reach over to the next element. Finally, we join the array of character and return it as a string.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%205%20Reverse%20Vowels%20of%20a%20String/#personal-thoughts","title":"Personal Thoughts","text":"<p>This was another wonderful solution presented by one of my friends which was implemented. Collaborative problem solving is very effective and can help to solve problem effectively by brainstroming.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%206%20Reverse%20Words%20in%20a%20String/","title":"151.\u00a0Reverse Words in a String","text":"<p>Tags: #twopointers #string #medium</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%206%20Reverse%20Words%20in%20a%20String/#problem-statement","title":"Problem Statement","text":"<p>Given an input string\u00a0<code>s</code>, reverse the order of the\u00a0words.</p> <p>A\u00a0word\u00a0is defined as a sequence of non-space characters. The\u00a0words\u00a0in\u00a0<code>s</code>\u00a0will be separated by at least one space.</p> <p>Return\u00a0a string of the words in reverse order concatenated by a single space.</p> <p>Note\u00a0that\u00a0<code>s</code>\u00a0may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p> <pre><code>Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%206%20Reverse%20Words%20in%20a%20String/#my-approach","title":"My approach","text":"<p><pre><code>class Solution:\n    def reverseWords(self, s: str) -&gt; str:\n        a = s.split()\n        if ( len(a) == 1):\n            return s\n        return \" \".join(a[::-1])\n</code></pre> In my approach, I kinda cheated for this problem since I used python's built in methods to first split the given string into an array of words using <code>s.split()</code> and then checked if the length of the array was 1, if it was returned the original string otherwise I first reversed the array through <code>a[::-1]</code> and then used <code>\" \".join()</code> to add the spaces in between words and return a string. <pre><code>class Solution:\n    def reverseWords(self, s: str) -&gt; str:\n        i = 0\n        j = len(s)-1\n        # Remove Front Spaces\n        while i &lt; len(s) and s[i] == \" \":\n            i += 1\n        # Remove back spaces\n        while j &gt;= 0 and s[j] == \" \":\n            j -= 1\n        ans = []\n        # run while we dont get to initial valid index i\n        while j &gt;= i:\n            # Trim middle spaces\n            while j &gt;= i and s[j] == \" \":\n                j -= 1\n            # Make  word reverse it \n            temp = []\n            while j &gt;= i and s[j] != \" \":\n                temp.append(s[j])\n                j -= 1\n            # Append word to original ans\n            ans.append(\"\".join(temp[::-1]))\n        return \" \".join(ans)\n</code></pre> Although my approach isn't the modal solution for the problem, I have found this solution which matches the LeetCode Description and solves the problem statement using the two pointer approach. The code comments pretty much explain the code.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%206%20Reverse%20Words%20in%20a%20String/#personal-thoughts","title":"Personal Thoughts","text":"<p>Well even though I took the more hacky approach, I do think it is a valid solution to the problem since there were no restrictions in the problem statement (Foreshadowing). I learned a lot too by going through the other solution that's why I included it here.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%207%20Product%20of%20Array%20Except%20Self/","title":"238.\u00a0Product of Array Except Self","text":"<p>Tags: #array #prefixsum #medium</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%207%20Product%20of%20Array%20Except%20Self/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array\u00a0<code>nums</code>, return\u00a0an array <code>answer</code> such that <code>answer[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p> <p>The product of any prefix or suffix of\u00a0<code>nums</code>\u00a0is\u00a0guaranteed\u00a0to fit in a\u00a032-bit\u00a0integer.</p> <p>You must write an algorithm that runs in\u00a0<code>O(n)</code>\u00a0time and without using the division operation.</p> <pre><code>Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%207%20Product%20of%20Array%20Except%20Self/#my-approach","title":"My approach","text":"<pre><code>class Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        length = len(nums)\n        result = [1] * length  \n        leftProduct = 1\n        for i in range(length):\n            result[i] *= leftProduct \n            leftProduct *= nums[i]  \n        rightProduct = 1\n        for i in range(length - 1, -1, -1):\n            result[i] *= rightProduct  \n            rightProduct *= nums[i] \n        return result\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%207%20Product%20of%20Array%20Except%20Self/#personal-thoughts","title":"Personal Thoughts","text":"<p>This question was quite hard, not due to the problem statement but due to the restriction of both O(n) time complexity and no division operation.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%208%20Increasing%20Triplet%20Subsequence/","title":"334.\u00a0Increasing Triplet Subsequence","text":"<p>Tags: #array #greedy #medium </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%208%20Increasing%20Triplet%20Subsequence/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array\u00a0<code>nums</code>, return\u00a0<code>true</code> if there exists a triple of indices <code>(i, j, k)</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[j] &lt; nums[k]</code>. If no such indices exists, return\u00a0<code>false</code>.</p> <p>Follow up:\u00a0Could you implement a solution that runs in\u00a0<code>O(n)</code>\u00a0time complexity and\u00a0<code>O(1)</code>\u00a0space complexity?</p> <pre><code>Input: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6.\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%208%20Increasing%20Triplet%20Subsequence/#my-approach","title":"My approach","text":"<p><pre><code>class Solution:\n    def increasingTriplet(self, nums):\n        f = float('inf')\n        s = float('inf')\n\n        for n in nums:\n            if n &lt;= f:\n                f = n\n            elif n &lt;= s:\n                s = n\n            else:\n                return True\n\n        return False\n</code></pre> In this solution, first we intialise two variable <code>f</code> and <code>s</code> to be infinity. Then, we loop over the nums array and compare the current element if it's smaller then <code>f</code>. Certainly in the first iteration, <code>n</code> will be smaller than <code>f</code> so, <code>f</code> is now assigned to be the current element. In the next iteration, we again check the condition and keep the smaller of the element in <code>f</code> (this means the smallest element will be in <code>f</code>) otherwise we reassign to <code>s</code> (this means that the element just larger to <code>f</code> will be in <code>s</code>) . Once again, checking through the conditions, if there are no more elements greater than f and s then we return <code>True</code> since our triplets condition is satisfied otherwise we return <code>False</code>.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%208%20Increasing%20Triplet%20Subsequence/#personal-thoughts","title":"Personal Thoughts","text":"<p>I couldn't come up with a solution to this problem on my own and had to go through the discussions tab in order to do this solution. I will come back to this problem once again, and try to solve this myself on a later date.</p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%209%20String%20Compression/","title":"443.\u00a0String Compression","text":"<p>Tags: #string #twopointers #medium </p>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%209%20String%20Compression/#problem-statement","title":"Problem Statement","text":"<p>Given an array of characters\u00a0<code>chars</code>, compress it using the following algorithm:</p> <p>Begin with an empty string\u00a0<code>s</code>. For each group of\u00a0consecutive repeating characters\u00a0in\u00a0<code>chars</code>:</p> <ul> <li>If the group's length is\u00a0<code>1</code>, append the character to\u00a0<code>s</code>.</li> <li>Otherwise, append the character followed by the group's length.</li> </ul> <p>The compressed string\u00a0<code>s</code> should not be returned separately, but instead, be stored\u00a0in the input character array\u00a0<code>chars</code>. Note that group lengths that are\u00a0<code>10</code>\u00a0or longer will be split into multiple characters in\u00a0<code>chars</code>.</p> <p>After you are done\u00a0modifying the input array,\u00a0return\u00a0the new length of the array.</p> <p>You must write an algorithm that uses only constant extra space.</p> <pre><code>Input: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\nOutput: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\nExplanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%209%20String%20Compression/#my-approach","title":"My approach","text":"<pre><code>class Solution:\n    def compress(self, chars: List[str]) -&gt; int:\n        result = \"\"\n        if len(chars) == 1:\n            return 1\n        chars.append(\" \")\n        count = 0\n        current = chars[0]\n        for i in range(len(chars)):\n            if current == chars[i]:\n                count +=1\n            else:\n                if count == 1:\n                    result += chars[i-1]\n                else:\n                    result += chars[i-1] + str(count)\n                current = chars[i]\n                count = 1\n        chars.clear()\n        chars.extend(result)\n        return len(chars)\n</code></pre>"},{"location":"Previous%20Attempts/LeetCode%2075/Day%209%20String%20Compression/#personal-thoughts","title":"Personal Thoughts","text":"<p>This is kind of a workaround solution that carefully tread around the requirement of constant extra space. I did use a new variable however in the end, changed the existing <code>chars</code> to be modified instead.</p>"}]}